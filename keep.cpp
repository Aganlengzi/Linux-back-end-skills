Linux后台开发应该具备技能
一、linux和os:
1、命令：netstat tcpdump ipcs ipcrm  这四个命令的熟练掌握程度基本上能体现实际开发和调试程序的经验
netstat：
显示网络状态

tcpdump：
主要是截获通过本机网络接口的数据，用以分析。能够截获当前所有通过本机网卡的数据包。它拥有灵活的过滤机制，可以确保得到想要的数据。
一个简单的例子：
tcpdump tcp -i eth1 -t -s 0 -c 100 and dst port ! 22 and src net 192.168.1.0/24 -w ./target.cap
(1)tcp: ip icmp arp rarp 和 tcp、udp、icmp这些选项等都要放到第一个参数的位置，用来过滤数据报的类型
(2)-i eth1 : 只抓经过接口eth1的包
(3)-t : 不显示时间戳
(4)-s 0 : 抓取数据包时默认抓取长度为68字节。加上-S 0 后可以抓到完整的数据包
(5)-c 100 : 只抓取100个数据包
(6)dst port ! 22 : 不抓取目标端口是22的数据包
(7)src net 192.168.1.0/24 : 数据包的源网络地址为192.168.1.0/24
(8)-w ./target.cap : 保存成cap文件，方便用ethereal(即wireshark)分析

ipcs：查看system V的进程间通信的各种资源情况的命令 
共享内存（-m）
消息队列（-q）
信号量 （-s） 
-a查看所有的ipc对象  

ipcrm：删除用id指定的ipc对象
-m共享内存
-q消息队列
-s信号量

2、cpu 内存 硬盘 等等与系统性能调试相关的命令必须熟练掌握，设置修改权限 tcp网络状态查看 各进程状态 抓包相关等相关命令 必须熟练掌握
3、awk sed需掌握
4、共享内存的使用实现原理、然后共享内存段被映射进进程空间之后，存在于进程空间的什么位置？共享内存段最大限制是多少？
5、c++进程内存空间分布（注意各部分的内存地址谁高谁低，注意栈从高道低分配，堆从低到高分配）
C/C++编译的程序占用内存的分布情况：
主要包括：
[代码区：text]存放函数可执行代码编译而来的二进制代码，程序结束后由系统释放。
[文字常量区：]存放常量字符串，程序结束后由系统释放。
[全局(静态)区]存放全局变量和静态变量，
初始化的全局变量和静态变量在一块区域中；
未初始化的全局变量和静态变量在相邻的另一块区域（BSS Block Started by Symbol），在程序执行前会自动清0
[栈区stack：]由高地址向低地址扩展
由编译器自动分配和释放，用于存放函数的参数值，局部变量值等等，
一般采用静态分配方式，可以动态分配，动态分配不需要手动释放。
其速度一般较快，相对于堆来说。
[堆区heap：]由低地址向高地址扩展
一般由程序员手动分配和释放，采用链表的形式进行组织，
如果分配了不释放可能会造成内存泄露，可能会由操作系统来回收。
其速度比较慢，并且容易产生内存碎片
6、ELF是什么？其大小与程序中全局变量的是否初始化有什么关系（注意.bss段）
7、使用过哪些进程间通讯机制，并详细说明
8、makefile编写，虽然比较基础，但是会被问到
9、gdb调试相关的经验，会被问到
10、如何定位内存泄露？
11、动态链接和静态链接的区别
12、32位系统一个进程最多多少堆内存
13、多线程和多进程的区别（重点 必须从cpu调度，上下文切换，数据共享，多核cup利用率，资源占用，等等各方面回答，然后有一个问题必须会被问到：哪些东西是一个线程私有的？答案中必须包含寄存器，否则悲催）
14、写一个c程序辨别系统是64位 or 32位
15、写一个c程序辨别系统是大端or小端字节序
16、信号：列出常见的信号，信号怎么处理？
17、i++是否原子操作？并解释为什么？？？？？？？
18、说出你所知道的各类linux系统的各类同步机制（重点），什么是死锁？如何避免死锁（每个技术面试官必问）
19、列举说明linux系统的各类异步机制
20、exit() _exit()的区别？
21、如何实现守护进程？
22、linux的内存管理机制是什么？
23、linux的任务调度机制是什么？
24、标准库函数和系统调用的区别？
25、补充一个坑爹坑爹坑爹坑爹的问题：系统如何将一个信号通知到进程？
二、c语言：
1、宏定义和展开（必须精通）
如果是展开，直接按照字符串展开，如果是书写宏定义，注意加括号

宏定义和typedef的区别
以宏定义形式定义的数据类型在声明变量的时候只能对第一个变量起作用，后面的不受其限制
但是宏定义的形式定义的变量类型可以被const等修饰扩展
以上两点主要和通过typedef形式声明新的变量类型相区别
例如 
#define pINT int *
pINT a, b; 		//a 是int *类型而b是int类型
const pINT c; 	//c 指向的int变量是const的

宏定义与const的区别
宏定义仅仅是字符串替换，而const是有类型的变量
宏定义在预处理阶段完成展开，const在编译阶段进行类型检查
宏定义有可能造成代码膨胀，const只有一份内存空间
有些调试工具可以对const类型变量进行调试，但是不能对宏定义进行

宏定义与内联函数的区别
宏定义仅仅是字符串替换，在调用或者定义的时候需要十分小心，否则容易在展开时出错(括号，前置后置++等)
inline函数首先是函数，主要是优化了函数调用时的压栈出栈开销，而直接将内联函数的代码放在了调用者的函数体中进行
宏定义没有类型检查，而inline函数有类型检查(函数调用有的它基本都有)
宏定义和inline函数都可能造成代码体积膨胀

2、位操作（必须精通）
3、指针操作和计算（必须精通）
4、内存分配（必须精通）
C语言中使用malloc和free进行内存的分配和回收操作，这两个函数是标准库函数
c++中使用new和delete进行内存的分配和回收操作，这两个是运算符，这两个操作符完成的功能过程大致如下：
new运算符执行过程：
首先调用名为operator new的标准库函数分配足够大的原始的未类型化的内存以保存指定的对象，
接下来运行适当的构造函数（对于类对象等），完成这块内存的类型化
最后返回指向这个新初始化的类对象的指针
delete运算符执行过程：
首先根据sp调用析构函数（对于类对象等）
然后调用名称为operator delete的标准库函数释放这块内存
从以上的过程可以看出，malloc/free和new/delete的区别：
前者是标准库函数，后者是运算符
对于非内部类型，前者不能调用构造函数和析构函数只能进行内存的分配和回收，malloc返回的是void*类型的地址
者能够通过标准库函数调用构造函数和析构函数
前者需要库文件的支持后者不需要库文件支持

5、各类库函数必须非常熟练的实现
6、哪些库函数属于高危函数，为什么？（strcpy等等）
三、c++：
1、一个String类的完整实现必须很快速写出来（注意：赋值构造，operator=是关键）
2、虚函数的作用和实现原理（必问必考，实现原理必须很熟）
虚函数用于实现面向对象c++语言中的三大特性(封装性继承性和多态性)中的多态
基本原理是：编译器为每个有虚函数的类创建一个虚函数表，该虚函数表被类的所有对象共享
每个虚函数占据其中的4个字节大小
在有虚函数的类的实例(对象)中分配了指向这个表的指针，当以基类的指针调用虚函数的时候，
此时的虚函数表指针用于找到对象的实际虚函数表并调用其中的虚函数(这个虚函数表是这个对象实际的类的)
虚函数表指针在每个对象的最前面
在一般继承时，子类改写的虚函数会覆盖基类的相应虚函数，子类新增的虚函数会放在虚函数表的后面
在多重继承时，每个父类都有一个虚函数表指针(每个指针都占用对象大小)，顺序按照声明顺序。
子类改写的虚函数会覆盖所有基类的相应虚函数，子类新增的虚函数会放在声明继承的第一个父类的虚函数表后面。

不能为虚函数
内联函数：内联函数要在编译阶段展开，虚函数是在运行时动态绑定的，所以不可以。
static函数：类的静态成员函数是为类共享的，而不是类的对象的，所以不存在多态的问题。
构造函数：类的对象都没有建立，不存在父类和子类的概念，多态无从谈起。所以在构造函数中调用虚函数只会调用本类中的函数。
析构函数可以为虚函数。

纯虚函数
有纯虚函数的类为抽象类，不能定义抽象类的对象，它的子类要么实现其所有的纯虚函数变为普通类，要么还是一个纯虚类。

3、sizeof一个类求大小（注意成员变量，函数，虚函数，继承等等对大小的影响）
没有虚函数和虚继承的类实例化后的对象大小至少为1字节（没有非静态数据成员的情况下也要有1个字节来记录它的地址）。
有虚函数的类的对象中会有指向此类的虚函数表的指针，指针的大小要算作对象的大小
sizeof后面跟的究竟是指针变量还是指针指向的变量实体
要考虑字节对齐
在不考虑（或者说在没有）虚函数和虚继承的情况下，sizeof(自定义类)也按照类似上面的方式来计算。
如果一个类拥有虚函数或者虚继承，则在数据成员的基础上相当于多一个指针类型的数据成员（位置在所有数据成员的前面），最后计算时加上即可。
如果一个类或者结构体不含有任何数据成员，且无虚函数以及虚继承，则sizeof()结果为1。
静态成员不在计算范围。

在系统默认的对齐方式下：
每个成员相对于这个结构体变量地址的偏移量正好是该成员类型所占字节的整数倍，
且最终占用字节数为成员类型中最大占用字节数的整数倍。

为什么要进行字节对齐？
当CPU访问正确对齐的数据时，它的运行效率最高，当数据大小的数据模数的内存地址是0时，数据是对齐的。
例如：WORD值应该是总是从被2除尽的地址开始，而DWORD值应该总是从被4除尽的地址开始，
数据对齐不是内存结构的一部分，而是CPU结构的一部分。
当CPU试图读取的数值没有正确的对齐时，CPU可以执行两种操作之一：
其一是产生一个异常条件；
其二是执行多次对齐的内存访问，以便读取完整的未对齐数据，若多次执行内存访问，应用程序的运行速度就会慢。


4、指针和引用的区别（一般都会问到）
指针声明不用初始化，引用必须要初始化
指针可以为空，引用不可以为空
指针是一个变量，可以根据需要修改，引用是一个别名，一旦初始化之后不能改变
指针在使用时需要解引用(*)引用不需要
指针可以按照变量利用const修饰，引用不可以
sizeof指针得到的是实际指针变量的大小，sizeof引用是本体的大小
指针和引用的自增自减运算含义不同

5、多重类构造和析构的顺序
构造：
首先调用父类的构造函数，按照在类派生表中的顺序递归进行
其次调用成员对象的构造函数，按照声明的顺序，而不是子类构造函数中进行参数赋值的顺序
然后是派生类的构造函数
析构：
还构造函数正好反过来

6、stl各容器的实现原理（必考）
7、extern c 是干啥的，（必须将编译器的函数名修饰的机制解答的很透彻）
extern "C"{}的作用是实现在C++程序中使用C语言。是C++和C之间的桥梁。
之所以要利用extern "C"是因为c++和C在生成符号的时候，编译器采用不同的处理方式：
在C语言中，因为不支持函数重载（C++的静态多态性），所以每个函数在程序中的符号只是前面加上两个下划线__的形式（一般情况下）
而在C++中，因为支持函数重载，并且参数的类型和个数也作为函数基调中的一部分，所以c++编译器将每个函数的函数名和参数都作为符号的一部分
变量也差不多。
extern "C"相当于告诉编译器，大括号中采用C语言的编译方式进行符号的编译，这样在使用的时候不会造成错误
extern "C"是c++中的关键字，C语言中没有这种用法

8、volatile是干啥用的，（必须将cpu的寄存器缓存机制回答的很透彻）
volatile本身含义是易失的，易挥发的，对程序中的变量来说它是容易改变的。
在C/C++中它是一种类型修饰符。它强制编译器不对其修饰的变量进行优化，
程序中每次使用它修饰的变量时，都需要从内存中取出这个变量值。
对于一些寄存器变量或者表示一个端口数据的变量如果不加volatile修饰就容易出错，因为：
编译器默认提供优化，如果某个值在前一次读出，而程序没有改变这个值，那么下次访问的时候就会直接给出这个值
并不会再从其所在的内存地址中取这个变量。如果此时别处对这个值进行了修改，程序并不会感知到，就会造成错误。

9、static const等等的用法，（能说出越多越好）
static的作用：
static修饰非类成员函数和成员变量：主要可以从三个方面进行考虑：作用域、生命周期和初始化
static生命的变量默认被初始化为0。
static修饰全局变量：此变量的作用域是整个程序范围内，存储在程序的静态存储区，生命周期是整个程序运行时间
static修饰局部变量：此变量的作用域在本作用域内，但是其存储在程序的静态存储区，生命周期是整个程序运行时间
static修饰普通函数：仅限于限制函数的作用域在本文件中。

static修饰类中的成员变量和成员函数：
static修饰成员变量：
表明此变量是整个类共享的，存放在程序的静态存储区，整个类只有这一份，不会被放在类的对象中。
遵从public、protected、private限制
通常在类的定义体外进行初始化，一些特殊的类型（比如说const static）可以在类中初始化。
可以通过类名和类的对象进行访问
只能在类定义中声明，在类外进行初始化，类外初始化不用static修饰
static修饰成员函数：
静态成员函数无this指针，无法访问属于类对象的非静态成员变量或者非静态成员函数
静态成员函数不能声明为const，因为const的语义是保证不对对象中的成员变量进行修改，类的static成员函数与类的对象关系不大
同理静态成员函数也不能被声明为virtual因为它不是类的对象的成员函数，而是类的函数
静态成员函数和静态成员变量之间可以互相访问，但是不能访问类的非静态成员函数
非静态成员函数可以任意访问类的静态成员函数和静态对象。

为什么要使用static——实际上从作用域和生命周期能够很好地解释（封装、限定作用范围、代码更明了）

const的作用：
c++默认const是内部连接的，c默认const是外部连接的
在c++中，全局的非const变量在整个程序中都是可以访问的。const变量是本文件中的局部变量，如果其它文件想访问，需要用extern进行修改
const修饰函数形参、返回值和函数本身
const修饰指针还是修饰指针指向的内容
const在类中的作用
const修饰的对象只能调用其const成员函数，不能调用其非const成员函数
非const对象可以调用const成员函数
类中const成员只能在类中声明，初始化必须在类的构造函数中进行，且初始化的方式是参数列表赋值形式。
如果两个函数只有常量性不同，则这两个函数的基调认为是不同的，可以进行重载

10、重载（overloading）和重写（overriding）
重写（overriding）是子类与父类之间多态性的表现
如果子类中定义的某个成员函数和父类的成员函数具有相同的名称和参数，我们就说这个成员函数被重写（overriding）了
子类的对象使用这个方法时，将调用子类中的定义，父类中的相同名称和参数的方法就被覆盖了
重载（overloading）是同类中不同方法的多态性的表现
如果一个类中定义了多个同名的函数，而他们的参数个数或者类型不同，我们就说这个函数被重载（overloading）了
重载函数间返回值可以不同


四、数据结构或者算法：
1、《离散数学》范围内的一切问题皆由可能被深入问到（这个最坑爹，最重要，最体现功底，最能加分，特别是各类树结构的实现和应用）
2、各类排序：大根堆的实现，快排（如何避免最糟糕的状态？），bitmap的运用等等
3、hash， 任何一个技术面试官必问（例如为什么一般hashtable的桶数会取一个素数？如何有效避免hash结果值的碰撞）
五、网络编程：
1、tcp与udp的区别（必问）
2、udp调用connect有什么作用？
3、tcp连接中时序图，状态图，必须非常非常熟练
4、socket服务端的实现，select和epoll的区别(必问)
5、epoll哪些触发模式，有啥区别？（必须非常详尽的解释水平触发和边缘触发的区别，以及边缘触发在编程中要做哪些更多的确认）
6、大规模连接上来，并发模型怎么设计
7、tcp结束连接怎么握手，time_wait状态是什么,为什么会有time_wait状态？哪一方会有time_wait状态，如何避免time_wait状态占用资源（必须回答的详细）
8、tcp头多少字节？哪些字段?(必问)
9、什么是滑动窗口（必问）
10、connect会阻塞，怎么解决?(必考必问，提示：设置非阻塞，返回之后用select检测状态)
11、如果select返回可读，结果只读到0字节，什么情况？
12、keepalive 是什么东东？如何使用？
13、列举你所知道的tcp选项，并说明其作用。
14、socket什么情况下可读？
六、db:
1、mysql，会考sql语言，服务器数据库大规模数据怎么设计，db各种性能指标
最后2、：补充一个最最重要，最最坑爹，最最有难度的一个题目：一个每秒百万级访问量的互联网服务器，每个访问都有数据计算和I/O操作，如果让你设计，你怎么设计？


七、后续添加
1、面向对象的特性
封装性、继承性、多态性
封装：把客观事物封装成抽象的类，可以隐藏实现细节，使代码模块化
继承：提高代码复用，避免重复造轮子
多态：以基类指针（或引用）指向子类调用虚函数实现相同的代码在运行时调用不同的行为
