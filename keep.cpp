Linux后台开发应该具备技能
一、linux和os:
1、命令：netstat tcpdump ipcs ipcrm  这四个命令的熟练掌握程度基本上能体现实际开发和调试程序的经验
ifconfig：网络接口的属性
netstat：显示网络统计信息，也可以用ss
如接口/网卡状态(-i)，路由表(-r)，网络连接(-a)，tcp相关选项(-t)，udp相关选项(-u)，按各个协议统计(-s)。
iptables -L：查看防火墙设置
route -n：查看路由表
tcpdump：抓包
主要是截获通过本机网络接口的数据，用以分析。能够截获当前所有通过本机网卡的数据包。它拥有灵活的过滤机制，可以确保得到想要的数据。
一个简单的例子：
tcpdump tcp -i eth1 -t -s 0 -c 100 and dst port ! 22 and src net 192.168.1.0/24 -w ./target.cap
(1)tcp: ip icmp arp rarp 和 tcp、udp、icmp这些选项等都要放到第一个参数的位置，用来过滤数据报的类型
(2)-i eth1 : 只抓经过接口eth1的包
(3)-t : 不显示时间戳
(4)-s 0 : 抓取数据包时默认抓取长度为68字节。加上-S 0 后可以抓到完整的数据包
(5)-c 100 : 只抓取100个数据包
(6)dst port ! 22 : 不抓取目标端口是22的数据包
(7)src net 192.168.1.0/24 : 数据包的源网络地址为192.168.1.0/24
(8)-w ./target.cap : 保存成cap文件，方便用ethereal(即wireshark)分析

ipcs：查看system V的进程间通信的各种资源情况的命令 
共享内存（-m）
消息队列（-q）
信号量 （-s） 
-a查看所有的ipc对象  

ipcrm：删除用id指定的ipc对象
-m共享内存
-q消息队列
-s信号量

2、cpu 内存 硬盘 等等与系统性能调试相关的命令必须熟练掌握，设置修改权限 tcp网络状态查看 各进程状态 抓包相关等相关命令 必须熟练掌握
2.1常用命令
ulimit	//用于查看或者设置系统中的用户资源情况，其中比较典型的是栈大小，最大可以打开的文件数，最大进程数等等
ulimit -a能够看到系统中当前用户的所有的资源限制情况，其中包含了一些进程间通信的资源等等
uname -a//查看linux内核版本信息
hostname//主机名
env		//环境变量
uptime	//系统运行时间，用户数和负载
free	//查看内存使用量和交换区使用量
df -h	//各分区使用情况
top		//当前各进程运行情况
在系统维护的过程中，随时可能有需要查看 CPU 使用率，并根据相应信息分析系统状况的需要。
运行 top 命令后，CPU 使用状态会以全屏的方式显示，并且会处在对话的模式，此时用基于 top 的命令，可以控制显示方式。
退出 top 的命令为 q。

3、awk sed需掌握

4、共享内存的使用实现原理、然后共享内存段被映射进进程空间之后，存在于进程空间的什么位置？共享内存段最大限制是多少？
共享内存是linux system V中的IPC方式中的一种。
它是最快的IPC方式，它允许多个不想管的进程去访问统一部分逻辑内存。
它不需要再内核和用户空间中来回拷贝数据，进程访问共享的内存就像是访问自己独占的内存一样。
使用者需要提供不同的方式保证同步和互斥。
共享内存的一般过程是：
通信间进程把自己的一段地址空间映射到操作系统提供的一块内存（可以通过ipcs查看操作系统中的共享内存），
在进程的地址空间中，这段地址空间的位置应该是栈下面紧靠近栈的地方
这些进程可以像访问自己进程的地址空间一样访问这块内存（不知道这块内存还被其他进程映射和访问）

5、c++进程内存空间分布（注意各部分的内存地址谁高谁低，注意栈从高道低分配，堆从低到高分配）
C/C++编译的程序占用内存的分布情况：
主要包括：
[ stack ]
[ DLL  ]
[ heap ]
[.BSS]
[.data]
[.text.rodata.init]
---------------
[代码区：text]存放函数可执行代码编译而来的二进制代码，程序结束后由系统释放。
[文字常量区：]存放常量字符串，程序结束后由系统释放。
[全局(静态)区]存放全局变量和静态变量，
初始化的全局变量和静态变量在一块区域中；
未初始化的全局变量和静态变量在相邻的另一块区域（BSS Block Started by Symbol），在程序执行前会自动清0
[栈区stack：]由高地址向低地址扩展
由编译器自动分配和释放，用于存放函数的参数值，局部变量值等等，
一般采用静态分配方式，可以动态分配，动态分配不需要手动释放。
其速度一般较快，相对于堆来说。
[堆区heap：]由低地址向高地址扩展
一般由程序员手动分配和释放，采用链表的形式进行组织，
如果分配了不释放可能会造成内存泄露，可能会由操作系统来回收。
其速度比较慢，并且容易产生内存碎片

堆和栈的区别
管理方式：对于栈来讲，是由编译器自动管理；对于堆来说，分配释放工作由程序员控制，容易造成内存泄露。
空间大小：一般来讲在32位系统下，堆内存可以达到4G的空间，从这个角度来看堆内存几乎是没有什么限制的。但是对于栈来讲，一般都是有一定的空间大小的。
碎片问题：对于堆来讲，频繁的new/delete势必会造成内存空间的不连续，从而造成大量的碎片，使程序效率降低。对于栈来讲，则不会存在这个问题。
生长方向：对于堆来讲，向着内存地址增加的方向增长；对于栈来讲，向着内存地址减小的方向增长。
分配方式：堆都是动态分配的，没有静态分配的堆。栈有2种分配方式：静态分配和动态分配。
分配效率：计算机在底层对栈提供支持，分配专门的寄存器存放栈的地址，压栈出栈都有专门的指令执行，这就决定了栈的效率比较高。堆则是C/C++函数库提供的，它的机制是很复杂的，效率比栈要低得多

6、ELF是什么？其大小与程序中全局变量的是否初始化有什么关系（注意.bss段）

7、使用过哪些进程间通讯机制，并详细说明

8、makefile编写，虽然比较基础，但是会被问到
9、gdb调试相关的经验，会被问到
10、如何定位内存泄露？
11、动态链接和静态链接的区别
链接是要做什么的？
链接所要解决的问题就是要让我们的程序能正确地找到程序中调用的库函数。
解决有两个思路：
一种方式是在生成可执行文件的时候，把被调用函数相关的二进制指令和数据包含在最终的可执行文件中，这就是静态链接；
另外一种方式是在程序运行的时候，再去加载printf函数相关的二进制指令和数据，这就是动态链接。
具体思路，每个源码文件都会被编译成目标文件，然后由链接器来链接生成最终的可执行文件
链接器在生成可执行文件的时候分为两种方式：
静态链接库的使用（静态链接过程）
静态链接就是在生成可执行文件的时候，把所有需要的函数的二进制代码都包含到可执行文件中去。
因此，链接器需要知道参与链接的目标文件需要哪些函数，同时也要知道每个目标文件都能提供什么函数，这样链接器才能知道是不是每个目标文件所需要的函数都能正确地链接。
当编译源文件的时候遇到依赖外部库中的函数时，这些函数的地址是被赋值为一个临时地址的，等到链接的时候这个函数（符号）的地址被修正为函数真正的地址。这个过程称作重定位
目标文件中有两个重要的接口来提供这些信息：一个是符号表（提供哪些符号），另外一个是重定位表（依赖哪些符号）
链接器会根据输入的目标文件从库文件中提取需要目标文件（只提取需要的那个目标文件，不是加载整个库）
链接器在链接的时候会先预处理一下，预处理的一个目的就是从库文件中找到需要的目标文件，从而确定是不是所有的符号都能找到。
链接器的输入是所有的目标文件和库文件（libc.a），链接器内部有一个list，里面维护的是没有找到的符号。
链接器依次读入输入的目标文件和库文件，如果目标文件中有需要链接的全局符号，就将其加入到那个list中，
比如在helloworld的那个例子，当处理到main.o的时候printf就被加入到那个list中。
当链接器在处理libc.a的时候，发现printf在那个list，于是就将printf.o这个文件保留下来，同时把printf从那个list中移除掉。
当所有输入的目标文件和库文件都处理完了以后，那个list中应该是空。如果不为空，说明有的符号没有找到，这时链接器会报告一个错误，不能链接。
在平常编译程序的时候，可能不会有将依赖的库放在编译命令中的习惯，实际上gcc默认是将一些库比如标准库作为链接器输入的。

动态链接库的使用（动态链接过程）
动态链接库的结构和可执行文件的结构相似：有数据段和代码段
为了使得动态库在内存中只有一份，需要做到不管动态库装载到什么位置，都不需要修改动态库中代码段的内容，从而实现动态库中代码段的共享。
而数据段中的内容需要做到进程间的隔离，因此必须是私有的，也就是每个进程都有一份。
因此，动态库的做法是把代码段中地址相关的内容（引用的外部函数或者变量）放到数据段中去，这样代码段中剩下的就是不变的内容，就可以装载到虚拟内存的任何位置。
那么如何找到这些地址相关的内容呢？
利用动态链接生成的可执行文件中保留了动态链接器和依赖库的信息（路径、名称等），库依赖的库也会被加载进来
当所有的库都被加载进来以后，类似于静态链接，动态链接器从各个动态库中可以知道每个库都提供什么函数（符号表）和哪些函数引用需要重定位（重定位表），
然后修正.got和.got.plt中的符号到正确的地址，完成之后就可以将控制权交给可执行文件的入口地址，从而开始执行我们编写的代码了

二者区别
静态链接库是一些object file（.o文件）通过ar工具打包而成，动态链接库利用gcc -shared -fPIC -o Lib.so Lib.c类似的生成
链接时机：静态链接在编译阶段确定，动态链接在执行阶段动态加载
内存大小：依赖相同静态链接库的程序中都会有一份这个静态链接库的拷贝，依赖相同动态链接库的程序共享同一个动态链接库，系统中只有一份
软件更新：依赖静态链接库的程序在更新时主要重新链接，依赖动态链接库的程序在更新时只需要更新库就可以了

12、32位系统一个进程最多多少堆内存
一般来讲在32位系统下，堆内存可以达到4G的空间2^32bits = 4GB
但是一般系统会对栈空间设置栈的大小限制，默认情况下用ulimit进行查看得到的结果是8M

13、多线程和多进程的区别（重点必须从cpu调度，上下文切换，数据共享，多核cup利用率，资源占用，等等各方面回答，然后有一个问题必须会被问到：哪些东西是一个线程私有的？答案中必须包含寄存器，否则悲催）
线程是进程的执行单元，进程至少有一个线程。
进程是资源分配的最小单位，线程是调度的最小单位
进程的切换代价高于线程，进程的通信、同步代价或者复杂度高于线程
进程的并发程度低于线程
进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进行产生影响，
但线程只是进程执行的不同路径，线程没有自己单独的地址空间，只有较小的堆栈、局部变量、寄存器、错误码之类的资源
一个线程死掉等于整个进程死掉，所以多进程的程序要比多线程的程序健壮

14、写一个c程序辨别系统是64位 or 32位
本质上是判断操作系统中的地址位数
int main()
{
	printf("%d\n",8*sizeof(void*));
}
如果想判断芯片的话，感觉只能通过系统保存的环境变量什么的吧

15、写一个c程序辨别系统是大端or小端字节序
用联合体union进行判断
bool checkCPUedian()
{
    union Test
    {
        int integer;
        char cha;
    }test;
    test.integer = 1;   //如果是小端，存储在最低字节处
    return test.cha;
}

int main()
{
    printf("%d\n",checkCPUedian());

}

16、信号：列出常见的信号，信号怎么处理？
SIGHUP（1）：挂起控制终端或者进程，缺省是terminate（nohup命令什么的相关）
SIGCHLD（17）：子进程结束的时候会给父进程发送这个信号 缺省是ignore（信号被忽略）
SIGSEGV（11）：当一个进程引用无效的内存的时候，缺省是dump（进程被杀死，如果有可能创建包含进程执行上下文的核心转储文件，这个文件可以用于调试）
SIGKILL（9）：强迫进城终止，缺省是terminate
SIGPIPE（13）：向无读者的管道写，缺省是terminate
SIGTERM（15）：进程终止，缺省是terminate

SIGSTOP、SIGKILL：不可以被显式地忽略捕获或者阻塞。

linux中的1-31是普通信号，32-64是实时信号，但是Linux系统中并不使用实时信号
普通信号和实时信号的区别是：普通信号发送给进程，不管发多少次，进程只会保留一个，实时信号需要排队，同一个信号发送多次在目标进程中就有多次

目前系统在处理信号的时候，会暂时屏蔽当前正在处理的这种信号，当信号处理完成后再解除屏蔽，这是通过在信号处理程序描述符中对某个信号的处理程序的描述符中设置相应屏蔽位的方法实现的
之所以这样做是因为，如果相同的信号又过来可能造成堆栈溢出

信号的大致过程如下：
在目的进程中安装该信号的处理函数，即设置捕获该信号时该进程该执行的操作码。采用signal();sigaction()系统调用来实现。存放在task_struct中的信号处理程序描述符中
信号的产生：被某个进程产生，同时设置该信号的目的进程（使用pid），之后交给操作系统进行管理。采用 kill()、arise()、alarm()等系统调用来实现。
信号在目的进程被注册。信号被添加进进程的PCB（task_struct）中相关的数据结构里——未决信号pending的数据成员。信号在进程中注册就是把信号值加入到进程的未决信号集里。并且，信号携带的其他信息被保留到未决信的队列的某个sigqueue结构中。
信号在进程中注销。在执行信号处理函数前，要把信号在进程中注销。对于非实时信号（不可靠信号），其在信号未决信号信息链中最多只有一个sigqueue结构，因此该结构被释放后，相应的信号要在未决信号集删除。而实时信号（可靠信号），如果有多个sigqueue，则不会把信号从进程的未决信号集中删除。
信号生命的终结。进程终止当前的工作（如果应该的话，即可被信号抢占的话），保护上下文，执行信号处理函数，之后恢复。如果内核是可抢占的，那么还需要调度。
这里需要注意信号处理程序的执行是在用户态的，信号处理的时机是进程从内核态返回用户态
进程在处理信号一定是在自己的运行上下文中，所以这个进程一定要处于运行状态
执行用户定义的函数的方法很巧妙，内核是在用户栈上创建一个新的层，该层中将返回地址的值设置成用户定义的处理函数的地址，这样进程从内核返回弹出栈顶时就返回到用户定义的函数处，从函数返回再弹出栈顶时， 才返回原先进入内核的地方。

内核对子进程终止（SIGCLD）信号的处理方法与其他信号有所区别。
当进程检查出收到了一个子进程终止的信号时，缺省情况下，该进程就象没有收到该信号似的，
如果父进程执行了系统调用wait，进程将从系统调用wait中醒来并返回wait调用，执行一系列wait调用的后续操作（找出僵死的子进程，释放子进程的进程表项），然后从wait中返回。
SIGCLD信号的作用是唤醒一个睡眠在可被中断优先级上的进程。如果该进程捕捉了这个信号，就象普通信号处理一样转到处理例程。
如果进程忽略该信号，那么系统调用wait的动作就有所不同，因为SIGCLD的作用仅仅是唤醒一个睡眠在可被中断优先级上的进程，那么执行wait调用的父进程被唤醒继续执行wait调用的后续操作，然后等待其他的子进程。 

17、i++是否原子操作？并解释为什么？？？？？？？
i++不是原子操作，它的执行分为三个阶段：
首先：内存到寄存器
其次：寄存器自增
最后：写回内存
这三个阶段中间都可以被中断分离开，所以并不能保证多个线程i++，操作同一个i，可以得到正确的结果。因为还有寄存器的因素，多个cpu对应多个寄存器。每次要先把i从内存复制到寄存器，然后++，然后再把i复制到内存中，这需要至少3步。从这个意义上讲，说i++是原子的并不对。
相关面试题目：
i++在两个线程里边分别执行100次，能得到的最大值和最小值分别是多少？
   假设两个线程的执行步骤如下：
1. 线程A执行第一次i++，取出内存中的i，值为0，存放到寄存器后执行加1，此时CPU1的寄存器中值为1，内存中为0；
2. 线程B执行第一次i++，取出内存中的i，值为0，存放到寄存器后执行加1，此时CPU2的寄存器中值为1，内存中为0；
3. 线程A继续执行完成第99次i++，并把值放回内存，此时CPU1中寄存器的值为99，内存中为99；
4. 线程B继续执行第一次i++，将其值放回内存，此时CPU2中的寄存器值为1，内存中为1；
5. 线程A执行第100次i++，将内存中的值取回CPU1的寄存器，并执行加1，此时CPU1的寄存器中的值为2，内存中为1；
6. 线程B执行完所有操作，并将其放回内存，此时CPU2的寄存器值为100，内存中为100；
7. 线程A执行100次操作的最后一部分，将CPU2中的寄存器值放回内存，内存中值为2；
8. 结束！
便可以得出最终结果，最小值为2，最大值为200。

18、说出你所知道的各类linux系统的各类同步机制（重点），什么是死锁？如何避免死锁（每个技术面试官必问）
同步机制：
原子操作
各种锁：互斥锁，信号量、自旋锁、读写锁、RCU等
死锁
死锁产生的条件：
互斥访问：一段时间内某种资源只能由一个进程占有
保持且请求：一个进程因请求资源而阻塞时，对已经获得的资源不释放
不可抢占：进程已经获得资源的情况下，在未使用完成之前，不能强行剥夺
循环等待：若干进程之间形成一种头尾相接的循环等待资源

19、列举说明linux系统的各类异步机制
异步机制：
信号：（软件中断）是在软件层次上对硬件中断的一种模拟
一个进程不需要为等待信号做任何事情，它不知道信号什么时候到来也不知道到来的信号是什么
但是它能够设置一旦信号到来它对这个信号做什么操作：
第一种：屏蔽这个信号，即不做处理
第二种：为某个特定信号设置相应的处理函数
第三种：使用系统的默认处理方式
在进程表的表项中，有一个可以保存未决信号的变量和保存信号处理函数的变量，
这样当有信号发送给某个进程，信号就被记录在这个未决信号变量上，
在信号处理时机到来时，内核检查某个进程有某个信号需要被处理，
调用信号的处理程序进行执行（如果有的话），可以参见上面的信号内容

IO多路转接（IO多路复用）技术：
普通读写文件，如果相应的读写请求得不到满足，进程往往会阻塞，
多个进程读一个文件的时候可以通过加锁的形式进行同步。另一个进程读不到就等待锁（阻塞等待某种资源）
一个进程读多个文件的时候通过多路转接的方法来高效进行，用到的主要是select，pselect，poll和epoll函数
I/O多路复用就是通过一种机制，可以监视多个描述符，一旦某个描述符就绪（一般是读就绪或者写就绪），能够通知程序进行相应的不阻塞的读写操作。
首先构造一张我们关心的描述符列表
然后调用一个函数，直到这个描述符表中的某个已经准备好进行某种I/O（读写等）该函数才返回，或者是该函数到达其等待的时间
等待一会儿查询一遍
返回后，调用者可以通过返回值和相应的参数修改值得知哪些描述符已经准备好了。

select：
int select(int maxfdpl, reasfds, writefds, exceptfds, time(微妙))
第一个参数是中间三个参数中指定的文件描述符最大值加1，表示最大要检查的文件描述符个数
中间三个参数分别代表了对读、写和异常事件感兴趣的描述符组f_set
最后一个参数是select函数的等待时间（timeval类型的，所以可以精确到微秒级别，如果处理器支持的话）
其中用到的应该是轮询的方式进行检查
有最大文件描述符数量的限制
每次在内核中检查的时候，需要将当前进程挂到每个感兴趣的设备（由参数给的描述符来指定）的等待队列上。
需要将用户的fd_set拷贝到内核空间，返回的时候从内核空间再拷回去
缺点：
（1）每次调用select，都需要把fd集合从用户态拷贝到内核态，这个开销在fd很多时会很大
（2）同时每次调用select都需要在内核遍历传递进来的所有fd，这个开销在fd很多时也很大（current轮流加入fd对应的设备等待队列中）
（3）select支持的文件描述符数量太小了，默认是1024

pselect
int pselect(int maxfdpl, reasfds, writefds, exceptfds, time(纳秒)，sigset)
第一个参数是中间三个参数中指定的文件描述符最大值加1，表示最大要检查的文件描述符个数
中间三个参数分别代表了对读、写和异常事件感兴趣的描述符组f_set
然后一个参数是select函数的等待时间（timeval类型的，所以可以精确到毫秒级别，如果处理器支持的话）
最后一个参数是信号屏蔽字，调用pselect函数期间屏幕相应的信号
其中用到的应该是轮询的方式进行检查
有最大文件描述符数量的限制

poll
int poll(struct fdarray[], nfds, int timeout)
第一个参数是一个结构体数组，其中的每一项中指定一个文件描述符和感兴趣的事件和留给系统设置的发生的感兴趣事件或者异常事件
struct pollfd {
int fd;         	/* 文件描述符 */
short events;      	/* 等待的事件 */
short revents;     	/* 实际发生了的事件 */
} ; 
第二个参数是数组的数量
第三个参数是poll函数等待的时间
其中用到的应该是轮询的方式进行检查
没有最大文件描述符数量的限制
其工作的过程和select十分相似，都是要完成拷贝文件描述符和current进程加入到等待设备的等待队列上

epoll
epoll是select和poll函数的增强版本，
epoll使用一个文件描述符管理多个描述符，将用户关心的文件描述符的事件存放到内核的一个事件表中，这样在用户空间和内核空间的copy只需一次。
#include <sys/epoll.h>
int epoll_create(int size);//size为监听的数目，但是不和maxfd一样，这个函数会创建一个fd用于管理这些文件描述符的监听工作
int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);//注册要监听的事件类型
int epoll_wait(int epfd, struct epoll_event * events, int maxevents, int timeout);//等待事件的产生
epoll对文件描述符的操作有两种模式：LT（level trigger）和ET（edge trigger）。LT模式是默认模式。
LT模式与ET模式的区别如下：
LT模式：当epoll_wait检测到描述符事件发生并将此事件通知应用程序，应用程序可以不立即处理该事件。下次调用epoll_wait时，会再次响应应用程序并通知此事件。
ET模式：当epoll_wait检测到描述符事件发生并将此事件通知应用程序，应用程序必须立即处理该事件。如果不处理，下次调用epoll_wait时，不会再次响应应用程序并通知此事件。
ET模式在很大程度上减少了epoll事件被重复触发的次数，因此效率要比LT模式高。
epoll工作在ET模式的时候，必须使用非阻塞套接口，以避免由于一个文件句柄的阻塞读/阻塞写操作把处理多个文件描述符的任务饿死。
解决select和poll函数的缺点：
对于第一个缺点，epoll的解决方案在epoll_ctl函数中。每次注册新的事件到epoll句柄中时（在epoll_ctl中指定EPOLL_CTL_ADD），会把所有的fd拷贝进内核，而不是在epoll_wait的时候重复拷贝。epoll保证了每个fd在整个过程中只会拷贝一次。
对于第二个缺点，epoll的解决方案不像select或poll一样每次都把current轮流加入fd对应的设备等待队列中，而只在epoll_ctl时把current挂一遍（这一遍必不可少）并为每个fd指定一个回调函数，当设备就绪，唤醒等待队列上的等待者时，就会调用这个回调函数，而这个回调函数会把就绪的fd加入一个就绪链表）。epoll_wait的工作实际上就是在这个就绪链表中查看有没有就绪的fd（利用schedule_timeout()实现睡一会，判断一会的效果，和select实现中的第7步是类似的）。
对于第三个缺点，epoll没有这个限制，它所支持的FD上限是最大可以打开文件的数目，这个数字一般远大于2048,举个例子,在1GB内存的机器上大约是10万左右，具体数目可以cat /proc/sys/fs/file-max察看,一般来说这个数目和系统内存关系很大。
1)select，poll实现需要自己不断轮询所有fd集合，直到设备就绪，期间可能要睡眠和唤醒多次交替。而epoll其实也需要调用epoll_wait不断轮询就绪链表，期间也可能多次睡眠和唤醒交替，但是它是设备就绪时，调用回调函数，把就绪fd放入就绪链表中，并唤醒在epoll_wait中进入睡眠的进程。虽然都要睡眠和交替，但是select和poll在“醒着”的时候要遍历整个fd集合，而epoll在“醒着”的时候只要判断一下就绪链表是否为空就行了，这节省了大量的CPU时间。这就是回调机制带来的性能提升。
2)select，poll每次调用都要把fd集合从用户态往内核态拷贝一次，并且要把current往设备等待队列中挂一次，而epoll只要一次拷贝，而且把current往等待队列上挂也只挂一次（在epoll_wait的开始，注意这里的等待队列并不是设备等待队列，只是一个epoll内部定义的等待队列）。这也能节省不少的开销。

IO多路复用的好处：
与多进程或者多线程相比，多路复用的好处是系统开销小。


20、exit() _exit()的区别？
exit()和_exit()函数都是进程正常终止的一种。
_exit终止调用进程，并立即返回给内核，但不清除输出缓存，也不调用出口函数。
exit函数将终止调用进程。在退出程序之前，可以看成是对_exit()函数的封装，在调用_exit()函数之前先执行一个标准IO库的清理关闭工作，效果是输出缓冲中所有数据被冲洗（写到文件上）。
在执行标准IO库的清理关闭工作之前，先调用各终止处理程序（由atexit定义，最多可以达到32个，同一个函数登记多次就调用多次，调用顺序和登记顺序相反）。
在main函数中exit(0)和return(0)等价

21、如何实现守护进程？
什么是守护进程
守护进程是脱离于控制终端的进程，用于在后台周期执行某种服务或者等待某种事件的发生并处理。
ps -axj   //a表示查看其它用户进程，x表示查看没有控制终端的进程，j表示查看与作业相关的进程
几个常见的守护进程：
kswapd：内存换页守护进程，虚拟内存子系统在经过一段时间后将脏页面慢慢地写回磁盘来回收这些页面
flush：在可用内存达到设置的最小阈值的时候将脏页面冲洗至磁盘，每个写回设备（比如磁盘）都有一个冲洗进程
inetd：真挺系统网络接口，以便取得来自网络的对各种网络服务进程的请求。
nfs相关的，表示对网络文件系统（network file system）相关的守护进程（分为内核级守护进程和用户级守护进程）
sshd：提供安全的远程登录和执行设施
用户级的守护进程的父进程都是init进程，这从其创建过程可以看出。
守护进程是普通进程改造而来的，只是在创建的时候或者创建后要满足几点要求
首先要做的是调用umask将文件模式创建屏蔽字设置为一个已知的值（通常是0）。
调用fork，然后使父进程退出
调用setsid创建一个新的会话，这样第一个子进程就会成为新会话的首进程，成为这个会话中新进程组的组长，并且这个会话没有控制终端
调用fork，然后父进程退出，此时第二个子进程不会是会话的首进程了，这样可以有效防止其再次会的终端
将当前的工作目录修改，一般修改为根目录chdir("/")
关闭不需要的文件描述符
守护进程打开/dev/null/使其具有文件描述符0,1,2。这样所有的交互（输入输出）都不能进行
以上完成一个守护进程的创建

22、linux的内存管理机制是什么？


23、linux的任务调度机制是什么？


24、标准库函数和系统调用的区别？
从用户使用的角度来看两者的区别并不是很大，它们都以C函数的形式出现，两者都为应用程序提供服务。

标准库函数一般可以替换，但是系统调用是系统（内核）封装给用户的接口，不可以替换
标准库函数是在用户层的，系统调是进入内核的接口。
标准库函数可以调用系统调用也可以不调用系统调用完成相应的工作
用户程序可以调用标准库函数或者通过直接调用系统调用完成相应功能

应用代码-->标准库函数-->系统调用
应用代码-->------------>系统调用

25、补充一个坑爹坑爹坑爹坑爹的问题：系统如何将一个信号通知到进程？

26、Linux IPC方式和WindowIPC方式
Linux中IPC方式：
经典的：
无名管道（pipe）：半双工、只能在具有亲缘关系的两个进程之间进行，构成一种文件系统，传送的是字节流，格式协议由双方事先达成共识
有名管道（fifo）：可以用于没有亲缘关系的两个进程。
信号（signal）：用于通知接收方某个事件已经发生了，传递信息量少。
system V：
信号量（semphare）：信号量本质上是一个计数器加锁。控制多个进程对共享资源的访问，主要作为同步手段。
共享内存（shared memory）：最高效的通信方式，将内存映射到两个不同的进程的地址空间进行，不需要内核空间和用户控件数据的拷贝。
消息队列（message queue）：消息构成的链表，克服了信号传递信息少和管道的无格式字节流以及缓冲区受限等缺点。
BSD：
套接字（socket）：最大的不同是可以用于不同主机之间的进程间通信。

Windows中IPC方式：
不是太知道... ...
文件映射

27、死锁
死锁产生的条件：
互斥访问：一段时间内某种资源只能由一个进程占有
保持且请求：一个进程因请求资源而阻塞时，对已经获得的资源不释放
不可抢占：进程已经获得资源的情况下，在未使用完成之前，不能强行剥夺
循环等待：若干进程之间形成一种头尾相接的循环等待资源

28、fork函数
fork函数调用处，整个父进程空间会赋值到子进程中，包括指令、变量值、程序调用栈、环境变量、缓冲区等
fork返回值有三种：
父进程中返回成功fork后的子进程pid
子进程中返回0
返回错误标识，一个负数
fork出错有两种原因：
首先是当系统中的进程数已经达到了系统规定的上限，errno被谁知为EAGAIN 可以通过ulimit进行查看或者设置
其次是系统的内存不足的时候，这时候errno被设置为ENOMEN
注意fork函数在循环中的缓冲区复制问题

29、进程状态转换
操作系统中，有三种最基本的状态：运行状态、就绪状态和等待状态
就绪状态——执行状态：调度程序按照一定的策略从就绪队列中选择一个进程并为其分配处理器之后，进程便进入执行状态。
执行状态——等待状态：正在执行的进程因需要等待某种事件的发生而无法继续执行，便进入等待状态，
					通常等待的时间主要是输入输出或者申请的资源得不到满足的情况下会发生这种状态变化。
等待状态——就绪状态：当进程等待的资源或者事件已经发生，此时进程进入就绪状态，等待调度程序调度执行。
执行状态——就绪状态：正在执行的进程因时间片用完或者被高优先级抢占之后进入就绪状态等待被调度执行

30.Linux中的僵尸进程和孤儿进程
孤儿进程：
顾名思义，就是没有父进程和进程，父进程在创建子进程之后先于子进程结束了。
孤儿进程在其称为孤儿进程的时候是没有结束的，
它会由init进程收养，此时init进程充当其父进程的角色，那么再也不会出现这个进程成为孤儿进程或者僵尸进程的情况了
孤儿进程不会产生什么危害

僵尸进程：
unix系统提供了父进程了解子进程运行信息的机制：子进程结束后，关于子进程的一些信息会保留给调用wait/waitpid的父进程，
这些信息中包括子进程的pid，退出状态和运行时间等等。父进程了解这些信息后会将这些信息释放。
但是如果父进程不对子进程调用wait/waitpid的话，这些信息没人管理，一直像僵尸一样在系统中游荡，所以有了僵尸进程的概念。
是死后（已经终止）没人管的进程，其父进程不愿意回收其资源（没有wait或者处理子进程发过来的SIGCHLD 信号）
这样子进程的资源虽然被释放（子进程退出的时候由系统完成）了，但是其保留的一些信息（子进程PID、退出状态和运行时间等）在系统中。
通过ps命令查看到的僵尸进程的标识是Z，它们占用着pid和小部分内存。
所以僵尸进程的危害也就可想而知了：
占用pid，占用一部分内存

怎样预防僵尸进程？
其一：父进程中调用wait/waitpid对每个子进程进行处理，对孩子负责，但是也会有短暂的时间子进程是僵尸进程，看具体应用情况能不能忍受
其二：父进程处理子进程退出时发送来的SIGCHILD信号，在信号处理函数中调用wait来处理僵尸进程
其三：采用fork两次方法避免产生僵尸进程
为什么要采用fork两次的方法？
如果采用fork一次父进程在子进程之前结束的方法是可以避免僵尸进程的。此时子进程因为没有父进程成为孤儿进程由init进程收养
但是无法避免在实际使用父子进程的时候父进程一定先结束。
另外，即使子进程在父进程之前结束且保证父进程调用waitpid来帮子进程收尸。在子进程结束到父进程调用waitpid这段时间子进程还是僵尸进程。
再者，保证父进程不处理子进程信息（想要让init进程成为子进程的父进程），在父进程结束之前子进程都是僵尸进程

如果发现系统中存在大量的僵尸进程应该怎么办？
ps查看僵尸进程及其父进程
通过发信号杀死其父进程  这样这些僵尸进程的僵尸信息会由init进程负责回收

http://www.cnblogs.com/Anker/p/3271773.html
二、c语言：
1、宏定义和展开（必须精通）
如果是展开，直接按照字符串展开，如果是书写宏定义，注意加括号

宏定义和typedef的区别
以宏定义形式定义的数据类型在声明变量的时候只能对第一个变量起作用，后面的不受其限制
但是宏定义的形式定义的变量类型可以被const等修饰扩展
以上两点主要和通过typedef形式声明新的变量类型相区别
例如 
#define pINT int *
pINT a, b; 		//a 是int *类型而b是int类型
const pINT c; 	//c 指向的int变量是const的

宏定义与const的区别
宏定义仅仅是字符串替换，而const是有类型的变量
宏定义在预处理阶段完成展开，const在编译阶段进行类型检查
宏定义有可能造成代码膨胀，const只有一份内存空间
有些调试工具可以对const类型变量进行调试，但是不能对宏定义进行

宏定义与内联函数的区别
宏定义仅仅是字符串替换，在调用或者定义的时候需要十分小心，否则容易在展开时出错(括号，前置后置++等)
inline函数首先是函数，主要是优化了函数调用时的压栈出栈开销，而直接将内联函数的代码放在了调用者的函数体中进行
宏定义没有类型检查，而inline函数有类型检查(函数调用有的它基本都有)
宏定义和inline函数都可能造成代码体积膨胀

2、位操作（必须精通）

3、指针操作和计算（必须精通）
数组与指针
注意在调用函数传参的时候，数组名自动退化为指针
一维数组的比较简单
二维数组：a[N][M]
a[0] <=>&a[0][0]  a[1] <=> &a[1][0]  a[1]+1 <=> &a[1][1]
*a[0] <=>a[0][0]  *a[1]<=>a[1][0]    *(a[1]+1 )<=>a[1][1]
a[x]是一个行指针，使用的时候按照一维数组
a是一个列指针，a+1相当于是a[1]
数组指针：指向数组的指针	int (*a)[N]
指针数组：存放指针的数组 	int* a[N] int* (a[N])


4、内存分配（必须精通）
C语言中使用malloc和free进行内存的分配和回收操作，这两个函数是标准库函数
c++中使用new和delete进行内存的分配和回收操作，这两个是运算符，这两个操作符完成的功能过程大致如下：
new运算符执行过程：
首先调用名为operator new的标准库函数分配足够大的原始的未类型化的内存以保存指定的对象，
接下来运行适当的构造函数（对于类对象等），完成这块内存的类型化
最后返回指向这个新初始化的类对象的指针
delete运算符执行过程：
首先根据sp调用析构函数（对于类对象等）
然后调用名称为operator delete的标准库函数释放这块内存
从以上的过程可以看出，malloc/free和new/delete的区别：
前者是标准库函数，后者是运算符
对于非内部类型，前者不能调用构造函数和析构函数只能进行内存的分配和回收，malloc返回的是void*类型的地址
者能够通过标准库函数调用构造函数和析构函数
前者需要库文件的支持后者不需要库文件支持

delete sp;          // 销毁 *sp, 然后释放 sp 指向的内存空间
delete [] arr;      // 销毁数组中的元素，然后释放对应的内存空间
数组中的元素按逆序销毁，即最后一个元素首先被销毁，然后是倒数第二个，依次类推

常见的内存错误
内存分配未成功，却使用了它。（在使用内存之前检查指针是否为NULL）
内存分配虽然成功，但是尚未初始化就引用它。（无论用何种方式创建数组，都应该初始化）
内存分配成功并且已经初始化，但操作越过了内存的边界。例如在使用数组时经常发生下标“多1”或者“少1”的操作。特别是在for循环语句中，循环次数很容易搞错，导致数组操作越界。
忘记了释放内存，造成内存泄露。动态内存的申请与释放必须配对，程序中malloc与free的使用次数一定要相同，否则肯定有错误（new/delete）。
释放了内存却继续使用它。

注意memset是对内存中的每个字节赋初值，所以在用的时候一般就用来初始化就好了。。。。
int b[10] = {3}; //只有b[0]被初始化为3，其它都是0

5、各类库函数必须非常熟练的实现

6、哪些库函数属于高危函数，为什么？（strcpy等等）
三、c++：
1、一个String类的完整实现必须很快速写出来（注意：赋值构造，operator=是关键）
2、虚函数的作用和实现原理（必问必考，实现原理必须很熟）
虚函数用于实现面向对象c++语言中的三大特性(封装性继承性和多态性)中的多态
如果基类希望子类覆盖实现的函数应该声明为虚函数，基类希望子类继承的函数不应该声明为虚函数
普通成员函数的绑定是静态绑定，在编译阶段决定，虚函数的绑定是动态绑定，在运行时进行绑定
基本原理是：编译器为每个有虚函数的类创建一个虚函数表，该虚函数表被类的所有对象共享
每个虚函数占据其中的4个字节大小
在有虚函数的类的实例(对象)中分配了指向这个表的指针，当以基类的指针调用虚函数的时候，
此时的虚函数表指针用于找到对象的实际虚函数表并调用其中的虚函数(这个虚函数表是这个对象实际的类的)
虚函数表指针在每个对象的最前面
在一般继承时，子类改写的虚函数会覆盖基类的相应虚函数，子类新增的虚函数会放在虚函数表的后面
在多重继承时，每个父类都有一个虚函数表指针(每个指针都占用对象大小)，顺序按照声明顺序。
子类改写的虚函数会覆盖所有基类的相应虚函数，子类新增的虚函数会放在声明继承的第一个父类的虚函数表后面。

不能为虚函数
内联函数：内联函数要在编译阶段展开，虚函数是在运行时动态绑定的，所以不可以。
static函数：类的静态成员函数是为类共享的，而不是类的对象的，所以不存在多态的问题。
构造函数：类的对象都没有建立，不存在父类和子类的概念，多态无从谈起。所以在构造函数中调用虚函数只会调用本类中的函数。
析构函数可以为虚函数。

纯虚函数
有纯虚函数的类为抽象类，不能定义抽象类的对象，它的子类要么实现其所有的纯虚函数变为普通类，要么还是一个纯虚类。

3、sizeof一个类求大小（注意成员变量，函数，虚函数，继承等等对大小的影响）
没有虚函数和虚继承的类实例化后的对象大小至少为1字节（没有非静态数据成员的情况下也要有1个字节来记录它的地址）。
有虚函数的类的对象中会有指向此类的虚函数表的指针，指针的大小要算作对象的大小
sizeof后面跟的究竟是指针变量还是指针指向的变量实体
要考虑字节对齐
在不考虑（或者说在没有）虚函数和虚继承的情况下，sizeof(自定义类)也按照类似上面的方式来计算。
如果一个类拥有虚函数或者虚继承，则在数据成员的基础上相当于多一个指针类型的数据成员（位置在所有数据成员的前面），最后计算时加上即可。
如果一个类或者结构体不含有任何数据成员，且无虚函数以及虚继承，则sizeof()结果为1。
静态成员不在计算范围。

在系统默认的对齐方式下：
每个成员相对于这个结构体变量地址的偏移量正好是该成员类型所占字节的整数倍，
且最终占用字节数为成员类型中最大占用字节数的整数倍。

为什么要进行字节对齐？
当CPU访问正确对齐的数据时，它的运行效率最高，当数据大小的数据模数的内存地址是0时，数据是对齐的。
例如：WORD值应该是总是从被2除尽的地址开始，而DWORD值应该总是从被4除尽的地址开始，
数据对齐不是内存结构的一部分，而是CPU结构的一部分。
当CPU试图读取的数值没有正确的对齐时，CPU可以执行两种操作之一：
其一是产生一个异常条件；
其二是执行多次对齐的内存访问，以便读取完整的未对齐数据，若多次执行内存访问，应用程序的运行速度就会慢。

sizeof是在编译阶段完成的，所以sizeof运算符后面括号中的计算都是不进行计算的，sizeof只关心类型大小
int i = 1;
sizeof(i++);
//i还是1
sizeof(string) 		//结果是4
sizeof(vector<int>)	//结果是12
char str[]="S\065AB"; sizeof(str)//结果是5
C语言: char a = 'a'; sizeof(char) = 1 sizeof(a) = 1 sizeof('a') = 4 
C++语言: char a = 'a'; sizeof(char) = 1 sizeof(a) = 1 sizeof('a') = 1 
字符型变量是1字节这个没错，奇怪就奇怪在C语言认为'a'是4字节，而C++语言认为'a'是1字节。原因如下:  
C99标准的规定，'a'叫做整型字符常量(integer    character constant)，被看成是int型，所以在32位机器上占4字节。
ISO C++标准规定，'a'叫做字符字面量(character literal)，被看成是char型，所以占1字节

4、指针和引用的区别（一般都会问到）
指针声明不用初始化，引用必须要初始化
指针可以为空，引用不可以为空
指针是一个变量，可以根据需要修改，引用是一个别名，一旦初始化之后不能改变
指针在使用时需要解引用(*)引用不需要
指针可以按照变量利用const修饰，引用不可以
sizeof指针得到的是实际指针变量的大小，sizeof引用是本体的大小
指针和引用的自增自减运算含义不同
指针可以有多级，引用只能是一级

5、多重类构造和析构的顺序
构造：
首先调用父类的构造函数，按照在类派生表中的顺序递归进行
其次调用成员对象的构造函数，按照声明的顺序，而不是子类构造函数中进行参数赋值的顺序
然后是派生类的构造函数
析构：
还构造函数正好反过来

6、stl各容器的实现原理（必考）
7、extern c 是干啥的，（必须将编译器的函数名修饰的机制解答的很透彻）
extern "C"{}的作用是实现在C++程序中使用C语言。是C++和C之间的桥梁。
之所以要利用extern "C"是因为c++和C在生成符号的时候，编译器采用不同的处理方式：
在C语言中，因为不支持函数重载（C++的静态多态性），所以每个函数在程序中的符号只是前面加上两个下划线__的形式（一般情况下）
而在C++中，因为支持函数重载，并且参数的类型和个数也作为函数基调中的一部分，所以c++编译器将每个函数的函数名和参数都作为符号的一部分
变量也差不多。
extern "C"相当于告诉编译器，大括号中采用C语言的编译方式进行符号的编译，这样在使用的时候不会造成错误
extern "C"是c++中的关键字，C语言中没有这种用法

8、volatile是干啥用的，（必须将cpu的寄存器缓存机制回答的很透彻）
volatile本身含义是易失的，易挥发的，对程序中的变量来说它是容易改变的。
在C/C++中它是一种类型修饰符。它强制编译器不对其修饰的变量进行读取和存储优化，
程序中每次使用它修饰的变量时，都需要从内存中取出这个变量值。
对于一些寄存器变量或者表示一个端口数据的变量如果不加volatile修饰就容易出错，因为：
编译器默认提供优化，如果某个值在前一次读入寄存器，而程序自身没有改变这个值，那么下次访问的时候就会直接从寄存器给出这个值
并不会再从其所在的内存地址中取这个变量。
因为程序认为只有自己才会修改这个值，也就是只要我不修改这个值，这个值就不会变，这对于一般的变量是正确的。
但是在一些应用场景中，比如DSP开发中，变量值的修改可能是由外部事件触发的：按键按下的中断服务程序
如果此时别处对这个值进行了修改，程序并不会感知到，就会造成错误。
编译器为什么要这么做呢？
由于访问寄存器的速度要快于访问RAM的速度，所以编译器一般都会作减少存取外部RAM的优化
volatile应用场景：
1、中断服务程序中修改的供其它程序检测的变量需要加volatile；
2、多任务环境下各任务间共享的标志应该加volatile；
3、存储器映射的硬件寄存器通常也要加volatile说明，因为每次对它的读写都可能由不同意义；


9、static const等等的用法，（能说出越多越好）
static的作用：
static修饰非类成员函数和成员变量：主要可以从三个方面进行考虑：作用域、生命周期和初始化
static生命的变量默认被初始化为0。
static修饰全局变量：此变量的作用域是整个程序范围内，存储在程序的静态存储区，生命周期是整个程序运行时间
static修饰局部变量：此变量的作用域在本作用域内，但是其存储在程序的静态存储区，生命周期是整个程序运行时间
static修饰普通函数：仅限于限制函数的作用域在本文件中。

static修饰类中的成员变量和成员函数：
static修饰成员变量：
表明此变量是整个类共享的，存放在程序的静态存储区，整个类只有这一份，不会被放在类的对象中。
遵从public、protected、private限制
通常在类的定义体外进行初始化，一些特殊的类型（比如说const static）可以在类中初始化。
可以通过类名和类的对象进行访问
只能在类定义中声明，在类外进行初始化，类外初始化不用static修饰
static修饰成员函数：
静态成员函数无this指针，无法访问属于类对象的非静态成员变量或者非静态成员函数
静态成员函数不能声明为const，因为const的语义是保证不对对象中的成员变量进行修改，类的static成员函数与类的对象关系不大
同理静态成员函数也不能被声明为virtual因为它不是类的对象的成员函数，而是类的函数
静态成员函数和静态成员变量之间可以互相访问，但是不能访问类的非静态成员函数
非静态成员函数可以任意访问类的静态成员函数和静态对象。

为什么要使用static——实际上从作用域和生命周期能够很好地解释（封装、限定作用范围、代码更明了）

const的作用：
c++默认const是内部连接的，c默认const是外部连接的
在c++中，全局的非const变量在整个程序中都是可以访问的。const变量是本文件中的局部变量，如果其它文件想访问，需要用extern进行修改
const修饰函数形参、返回值和函数本身
const修饰指针还是修饰指针指向的内容
const在类中的作用
const修饰的对象只能调用其const成员函数，不能调用其非const成员函数
非const对象可以调用const成员函数
类中const成员只能在类中声明，初始化必须在类的构造函数中进行，且初始化的方式是参数列表赋值形式。（引用类型的成员也要这么干）
如果两个函数只有常量性不同，则这两个函数的基调认为是不同的，可以进行重载

10、重载（overloading）和重写（overriding）还用重定义（redefining）
重写（overriding）是子类与父类之间多态性的表现
子类重新定义基类中有相同名称和参数（都相同）的虚函数（一定要是虚函数）
重写和被重写的函数的返回值要么相同，要么都是指针或者引用，或者重写函数返回值是被重写函数返回的指针或者引用的子类型
重写的函数的访问修饰符(private等)可以和被重写函数不同

重载（overloading）是同类中不同方法的多态性的表现
如果一个类中定义了多个同名的函数，而他们的参数个数或者类型不同（一定不会完全相同），我们就说这个函数被重载（overloading）了
重载函数间返回值可以不同
重载函数在相同作用域下

重定义（redefining）也叫隐藏，子类中重新定义父类的非虚函数，屏蔽父类中的此非虚函数
两者的作用域不同
子类和父类中函数名称相同，参数不相同，父类的函数都将被隐藏（不管是不是虚函数，参数不同肯定不是重写了）
子类和父类中函数名称相同，参数也相同，父类的非虚函数被隐藏（虚函数是被重写了，非虚函数被隐藏）

11、c++中强制类型转换
reinterpret_cast: 
转换一个指针为另一个指针，不要求二者之间存在关联，只是做二进制的拷贝，指针和整型类型之间的转换也是支持的
static_cast: 
所有的隐式转换或者相反转换，典型的是在下行转换的时候不会进行类型检查，而直接转换。
dynamic_cast:
只用于对象的指针和引用。会对下行转换（基类指针转换成子类指针）进行类型检查，只有需要被转换的指针指的对象真正是转向的类型的时候才成功。
const_cast: 
这个转换类型操纵传递对象的const属性，或者是设置或者是移除

四、数据结构或者算法：
1、《离散数学》范围内的一切问题皆由可能被深入问到（这个最坑爹，最重要，最体现功底，最能加分，特别是各类树结构的实现和应用）
2、各类排序：大根堆的实现，快排（如何避免最糟糕的状态？），bitmap的运用等等
3、hash， 任何一个技术面试官必问（例如为什么一般hashtable的桶数会取一个素数？如何有效避免hash结果值的碰撞）

五、网络编程：
1、tcp与udp的区别（必问）
TCP---传输控制协议,提供的是面向连接、可靠的字节流服务。
当客户和服务器彼此交换数据前，必须先在双方之间建立一个TCP连接（三次握手），之后才能传输数据。
检验数据（checksum），
流量控制（urgent and window）等功能，
针对乱序：在通过三次握手进行链接时，序列号被初始化。在传输过程中，TCP继续使用这个序列号来标记发送的每一个数据段，每传送一个数据段，序列号加1。接收方依据序列号重装收到的数据段。
针对丢包：在传输过程中，接收方收到一个数据段后，会用ACK应答码向发送端回复一个IP包进行应答，确认号ACK用来告诉发送端哪些数据包已经成功接收，发送方对未被应答的报文段提供重传。
针对重复：接收端收到数据段后，查看序列号，如果已经成功接收改数据包，则丢弃后面这个数据段。
针对延时：延时造成的第一个问题，就是数据包达到接收端时乱序。当延时严重时，接收端一直未收到数据段，则不会回复ACK，发送端认为丢包，重发。

保证正常断开连接（四次挥手）保证数据能从一端传到另一端。
TCP好比打电话，必须先接通然后传输数据，传输数据的时候一应一答，之后挂断。
说它开销大，主要是建立连接和流量控制、数据校验等功能

--------------------------
UDP---用户数据报协议，是一个简单的面向数据报的运输层协议。
UDP不提供可靠性，它只是把应用程序传给IP层的数据报发送出去，
但是并不能保证它 们能到达目的地。
由于UDP在传输数据报前不用在客户和服务器之间建立一个连接，且没有超时重发等机制，故而传输速度很快
UDP好比发短信，发送者尽管发送，并不知道是否已经发送成功
数据报报头8字节
说它开销小，主要是指它不需要三次握手建立连接

2、udp调用connect有什么作用？
TCP的connect会触发三次握手
而udp的connect只是：
绑定了对端，内核只会将绑定对象的对端发送来的数据包传给套接口，因此可以在一定环境中提升安全性
能够提高效率，对端已经确定了：udp不connect情况下的过程是：建立连接发送数据断开连接，循环往复，但是如果绑定了ip和端口，那么中间的断开连接和建立连接可以省去了
一个已经调用connect的udp可以再次调用udp以指定新的IP地址和端口号或者断开套接口
（1）UDP中可以使用connect系统调用。
（2）UDP中connect操作与TCP中connect操作有着本质区别。TCP中调用connect会引起三次握手，client与server建立连结。UDP中调用connect内核仅仅把对端ip&port记录下来。
（3）UDP中可以多次调用connect，TCP只能调用一次connect。

3、tcp连接中时序图，状态图，必须非常非常熟练
三次握手：
A(client)======>B(server)
SYN:seq=X;				[A:CLOSED-->SYN_SENT; B:CLOSED-->LISTEN]
SYN:seq=Y ACK:ack=X+1;	[A:SYN_SENT-->ESTABLISED; B:LISTEN-->SYN_RCVD] ACK此时发型的是期望下一次应该接收到的包的序列号：预期确认
SYN:seq=X+1 ACK:ack=Y+1	[A:ESTABLISHED; B:SYN_RCVD-->ESTABLISHED]
三次握手使双方建立一种逻辑上的连接，并且使通信双方统一了初始化序列号。
-------------
四次挥手：
A(client)<======>B(server)
[A:ESTABLISHED-->FIN_WAIT_1; B:ESTABLISHED-->CLOSE_WAIT]
[A:FIN_WAIT_1-->FIN_WAIT_2; B:CLOSE_WAIT]
[A:FIN_WAIT_2-->TIME_WAIT; B:CLOSE_WAIT-->LAST_ACK]
[A:TIME_WAIT-->CLOSED; B:LAST_ACK-->CLOSED]

4、socket服务端的实现，select和epoll的区别(必问)
IO多路转接（IO多路复用）技术：
普通读写文件，如果相应的读写请求得不到满足，进程往往会阻塞，
多个进程读一个文件的时候可以通过加锁的形式进行同步。另一个进程读不到就等待锁（阻塞等待某种资源）
一个进程读多个文件的时候通过多路转接的方法来高效进行，用到的主要是select，pselect，poll和epoll函数
I/O多路复用就是通过一种机制，可以监视多个描述符，一旦某个描述符就绪（一般是读就绪或者写就绪），能够通知程序进行相应的读写操作。
首先构造一张我们干星期的描述符列表
然后调用一个函数，直到这个描述符表中的某个已经准备好进行某种I/O（读写等）该函数才返回。
返回后，调用者可以通过返回值和相应的参数修改值得知哪些描述符已经准备好了。

select：
int select(int maxfdpl, reasfds, writefds, exceptfds, time(微妙))
第一个参数是中间三个参数中指定的文件描述符最大值加1，表示最大要检查的文件描述符个数
中间三个参数分别代表了对读、写和异常事件感兴趣的描述符组f_set
最后一个参数是select函数的等待时间（timeval类型的，所以可以精确到毫秒级别，如果处理器支持的话）
其中用到的应该是轮询的方式进行检查
有最大文件描述符数量的限制
需要将用户的fd_set拷贝到内核空间，返回的时候从内核空间再拷回去
缺点：
（1）每次调用select，都需要把fd集合从用户态拷贝到内核态，这个开销在fd很多时会很大
（2）同时每次调用select都需要在内核遍历传递进来的所有fd，这个开销在fd很多时也很大（current轮流加入fd对应的设备等待队列中）
（3）select支持的文件描述符数量太小了，默认是1024

pselect
int pselect(int maxfdpl, reasfds, writefds, exceptfds, time(纳秒)，sigset)
第一个参数是中间三个参数中指定的文件描述符最大值加1，表示最大要检查的文件描述符个数
中间三个参数分别代表了对读、写和异常事件感兴趣的描述符组f_set
然后一个参数是select函数的等待时间（timeval类型的，所以可以精确到毫秒级别，如果处理器支持的话）
最后一个参数是信号屏蔽字，调用pselect函数期间屏幕相应的信号
其中用到的应该是轮询的方式进行检查
有最大文件描述符数量的限制

poll
int poll(struct fdarray[], nfds, int timeout)
第一个参数是一个结构体数组，其中的每一项中指定一个文件描述符和感兴趣的事件和留给系统设置的发生的感兴趣事件或者异常事件
struct pollfd {
int fd;         	/* 文件描述符 */
short events;      	/* 等待的事件 */
short revents;     	/* 实际发生了的事件 */
} ; 
第二个参数是数组的数量
第三个参数是poll函数等待的时间
其中用到的应该是轮询的方式进行检查
没有最大文件描述符数量的限制

epoll
epoll是select和poll函数的增强版本，
epoll使用一个文件描述符管理多个描述符，将用户关心的文件描述符的事件存放到内核的一个事件表中，这样在用户空间和内核空间的copy只需一次。
#include <sys/epoll.h>
int epoll_create(int size);//size为监听的数目，但是不和maxfd一样，这个函数会创建一个fd用于管理这些文件描述符的监听工作
int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);//注册要监听的事件类型
int epoll_wait(int epfd, struct epoll_event * events, int maxevents, int timeout);//等待事件的产生
解决select和poll函数的缺点：
对于第一个缺点，epoll的解决方案在epoll_ctl函数中。每次注册新的事件到epoll句柄中时（在epoll_ctl中指定EPOLL_CTL_ADD），会把所有的fd拷贝进内核，而不是在epoll_wait的时候重复拷贝。epoll保证了每个fd在整个过程中只会拷贝一次。
对于第二个缺点，epoll的解决方案不像select或poll一样每次都把current轮流加入fd对应的设备等待队列中，而只在epoll_ctl时把current挂一遍（这一遍必不可少）并为每个fd指定一个回调函数，当设备就绪，唤醒等待队列上的等待者时，就会调用这个回调函数，而这个回调函数会把就绪的fd加入一个就绪链表）。epoll_wait的工作实际上就是在这个就绪链表中查看有没有就绪的fd（利用schedule_timeout()实现睡一会，判断一会的效果，和select实现中的第7步是类似的）。
对于第三个缺点，epoll没有这个限制，它所支持的FD上限是最大可以打开文件的数目，这个数字一般远大于2048,举个例子,在1GB内存的机器上大约是10万左右，具体数目可以cat /proc/sys/fs/file-max察看,一般来说这个数目和系统内存关系很大。

IO多路复用的好处：
与多进程或者多线程相比，多路复用的好处是系统开销小。
1)select，poll实现需要自己不断轮询所有fd集合，直到设备就绪，期间可能要睡眠和唤醒多次交替。而epoll其实也需要调用epoll_wait不断轮询就绪链表，期间也可能多次睡眠和唤醒交替，但是它是设备就绪时，调用回调函数，把就绪fd放入就绪链表中，并唤醒在epoll_wait中进入睡眠的进程。虽然都要睡眠和交替，但是select和poll在“醒着”的时候要遍历整个fd集合，而epoll在“醒着”的时候只要判断一下就绪链表是否为空就行了，这节省了大量的CPU时间。这就是回调机制带来的性能提升。
2)select，poll每次调用都要把fd集合从用户态往内核态拷贝一次，并且要把current往设备等待队列中挂一次，而epoll只要一次拷贝，而且把current往等待队列上挂也只挂一次（在epoll_wait的开始，注意这里的等待队列并不是设备等待队列，只是一个epoll内部定义的等待队列）。这也能节省不少的开销。

5、epoll哪些触发模式，有啥区别？（必须非常详尽的解释水平触发和边缘触发的区别，以及边缘触发在编程中要做哪些更多的确认）
epoll对文件描述符的操作有两种模式：LT（level trigger）和ET（edge trigger）。LT模式是默认模式，LT模式与ET模式的区别如下：
LT模式：当epoll_wait检测到描述符事件发生并将此事件通知应用程序，应用程序可以不立即处理该事件。下次调用epoll_wait时，会再次响应应用程序并通知此事件。
ET模式：当epoll_wait检测到描述符事件发生并将此事件通知应用程序，应用程序必须立即处理该事件。如果不处理，下次调用epoll_wait时，不会再次响应应用程序并通知此事件。
ET模式在很大程度上减少了epoll事件被重复触发的次数，因此效率要比LT模式高。
epoll工作在ET模式的时候，必须使用非阻塞套接口，以避免由于一个文件句柄的阻塞读/阻塞写操作把处理多个文件描述符的任务饿死。

6、大规模连接上来，并发模型怎么设计
（1）单线程/阻塞/同步模型
适用范围：单一连接
缺点：多连接时相互影响，一个阻塞，别的也得不到响应

（2）多进程/阻塞/同步模型
适用范围：连接数较少，且使用的资源较多，比如文件操作
缺点：系统进程数有上限，不适用大量并发连接，且进程间切换开销较大

（3）多线程/阻塞/同步模型
适用范围：连接数较少，且使用系统资源不多，可多个线程共享
缺点：系统线程数有上限，不适用大量并发连接，且线程间的需要保护

（4）单线程/非阻塞/同步模型
特征：强行逐个连接轮询处理，没有探测
适用范围：连接数较少
缺点：需要处理数据的拼接，且凭空占用资源，CPU高

（5）select事件驱动模型(单线程/阻塞/同步模型/先探测后处理/挂起式阻塞)
特征：事件驱动，先集中探测事件，再对有事件的连接逐一响应
适用范围：连接数中
缺点：探测效率不高，且探测和处理处于同一线程，处理时间较长时容易影响探测；

（6）平台相关的事件驱动（双线程/阻塞/异步模型/先探测后处理/挂起式阻塞/探测和响应线程分离）
特征：使用特殊平台自身的接口，linux为poll、epoll，BSD为kqueue、solaris为/dev/poll、windows为iocp；    
适用范围：大量并发连接
优点：使用消息队列或信号等方式将事件探测和响应分离在不同线程，从而确保事件探测不会被响应影响；
            探测和响应的线程都使用了挂起机制，从而有效防止了线程空转，只占用很少的资源；            
缺点：难于跨平台

（7）开源跨平台事件驱动模型（双线程/阻塞/异步模型/先探测后处理/挂起式阻塞/探测和响应线程分离）
适用范围：大量并发连接
优点：跨平台        
缺点：需要第三方开源库来移植和封装平台
开源例子：libev、libevent、ACE、asio

（8）事件驱动模型的抽象
最大限度地利用网络本身的并发能力；
本地资源不能成为网络并发瓶径；
多个连接之间不能相互阻塞；
事件响应不能阻塞事件探测；
线程无任务时不能空转；

（9）网络I/O术语
单线程/多线程/多进程
阻塞/挂起式阻塞/超时阻塞/非阻塞/空转/轮询
同步/异步/消息队列/信号
先探测/后响应/集中探测/线程分离
并发连接数
开源/跨平台

7、tcp结束连接怎么握手，time_wait状态是什么,为什么会有time_wait状态？哪一方会有time_wait状态，如何避免time_wait状态占用资源（必须回答的详细）
哪一方会有TIME_WAIT状态：
time_wait状态是TCP/IP状态的一种，通信双方建立TCP链接后，主动关闭连接的一方会进入TIME_WAIT状态
客户端主动关闭连接时，发送FIN后进入FIN_WAIT_1，接收到server的ACK之后进入FIN_WAIT_2，接收到server的FIN，会发送最后一个ack后，
然后会进入TIME_WAIT状态，再停留2个MSL时间(后有MSL的解释)，进入CLOSED状态。

为什么会有TIME_WAIT状态存在：
首先，是为了可靠地实现TCP全双工连接的终止，如果主动发送FIN的一方确认其FIN的ACK之后进入CLOSED状态
那么只是关闭了一方，如果此时另一方发送FIN，没有人会给它回应对应的ACK状态，会产生错误
其次，为什么要是2MSL呢？
是要让关闭的上次连接中的所有的分组都在网络中消逝
TCP不允许处于TIME_WAIT状态的一方建立新的连接
如果不是2MSL的话，可能关闭上一个连接之后又建立了新的连接，而残留在网络上的上一次的分组可能影响新的连接
所以应该等待让上一次残留的分组在网络中消逝殆尽。

MSL就是maximum segment lifetime(最大分节生命期），这是一个IP数据包能在互联网上生存的最长时间，超过这个时间IP数据包将在网络中消失 。MSL在RFC 1122上建议是2分钟，而源自berkeley的TCP实现传统上使用30秒。

TIME_WAIT状态下的socket不能被重新回收利用
主要占用的资源是fd和端口号
解决的方法是将TIME_WAIT的等待时间设置更短一些
一般不会出现这个问题，并且TIME_WAIT状态下并不会占用太多的系统资源，
可能是软件方面出错，比如没有及时关闭导致的大量TIME_WAIT状态后者是攻击
应该找出根本原因之后从根本上解决
尽量让客户端发送主动断开连接请求

8、tcp头多少字节？哪些字段?(必问)
TCP头20字节：
源端口(16)目标端口(16)
序号(32)
应答号(32)
头长度(4)保留(6)编码位(6)窗口(16)
校验和(16)紧急(16)

UDP头8字节
源端口(16)目标端口(16)
报文长度(16)校验和(16)

9、什么是滑动窗口（必问）
TCP基于sequence和ack的预期确认机制每次只能确认一个数据包，这限制了传输的速度。
为了充分利用带宽，TCP使用窗口技术。
滑动窗口允许发送方在收到接收方的确认之前发送多个数据段。（窗口大小决定了在收到确认前可以发送的数据段数量）
窗口数决定了当前传输的最大流量。当我们在传输过程中，通信双方可以根据网络条件动态协商窗口大小，调整窗口大小时，即可实现流量控制。（在TCP的每个确认中，除了ACK外，还包括一个窗口通知）

10、connect会阻塞，怎么解决?(必考必问，提示：设置非阻塞，返回之后用select检测状态)
http://blog.sina.com.cn/s/blog_6592a07a0102v4sk.html
步骤1： 设置非阻塞，启动连接4
实现非阻塞 connect ，首先把 sockfd 设置成非阻塞的。这样调用connect 可以立刻返回，根据返回值和 errno 处理三种情况：
(1) 如果返回0，表示 connect 成功。
(2) 如果返回值小于0，errno为 EINPROGRESS,  表示连接建立已经启动但是尚未完成。这是期望的结果，不是真正的错误。
(3) 如果返回值小于0，errno不是 EINPROGRESS，则连接出错了。
 
步骤2：判断可读和可写
然后把 sockfd 加入 select 的读写监听集合，通过 select 判断 sockfd是否可写，处理三种情况：
(1) 如果连接建立好了，对方没有数据到达，那么 sockfd 是可写的
(2) 如果在 select 之前，连接就建立好了，而且对方的数据已到达，那么 sockfd 是可读和可写的。
(3) 如果连接发生错误，sockfd 也是可读和可写的。
判断 connect 是否成功，就得区别 (2) 和 (3)，这两种情况下 sockfd 都是可读和可写的，区分的方法是，调用 getsockopt 检查是否出错。
 
步骤3：使用 getsockopt 函数检查错误
getsockopt(sockfd, SOL_SOCKET, SO_ERROR, &error, &len)
在 sockfd 都是可读和可写的情况下，我们使用 getsockopt 来检查连接是否出错。但这里有一个可移植性的问题。
如果发生错误，getsockopt 源自 Berkeley 的实现将在变量 error 中返回错误，getsockopt 本身返回0；
然而 Solaris 却让 getsockopt 返回 -1，并把错误保存在 errno 变量中。所以在判断是否有错误的时候，要处理这两种情况。

11、如果select返回可读，结果只读到0字节，什么情况？
12、keepalive 是什么东东？如何使用？
13、列举你所知道的tcp选项，并说明其作用。
urgent：用于紧急传送数据
14、socket什么情况下可读？

六、db:
1、mysql，会考sql语言，服务器数据库大规模数据怎么设计，db各种性能指标
最后2、：补充一个最最重要，最最坑爹，最最有难度的一个题目：一个每秒百万级访问量的互联网服务器，每个访问都有数据计算和I/O操作，如果让你设计，你怎么设计？

七、后续添加
1、面向对象的特性
封装性、继承性、多态性
封装：把客观事物封装成抽象的类，可以隐藏实现细节，使代码模块化
继承：提高代码复用，避免重复造轮子
多态：以基类指针（或引用）指向子类调用虚函数实现相同的代码在运行时调用不同的行为
